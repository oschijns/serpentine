import "src/nes";
import "src/define";
import "src/math";
import "src/video";


namespace physics {

    in zeropage {
        // the main box to test collisions with
        var primary_box: Box2;
    }

    // specify how many bits are allocated for sub-pixel position
    let SUB_PIXEL_BITS_X = 3;
    let SUB_PIXEL_BITS_Y = 4;

    // maximum velocity for objects
    let MAX_VELOCITY = 12;

    // maximum number of bodies in the simulation
    let MAX_BODIES_COUNT = 12;

    // arrays containing position, velocity and acceleration of bodies
    struct Bodies {
        position_low  : [u8; MAX_BODIES_COUNT],
        position_high : [u8; MAX_BODIES_COUNT],
        velocity      : [u8; MAX_BODIES_COUNT],
        acceleration  : [u8; MAX_BODIES_COUNT],
    }

    in ram {

        // current number of bodies in the simulation
        var bodies_count : u8;

        // array storing physics bodies data
        var bodies_x, bodies_y : Bodies;
    }


    // mask for collision sides
    let COLLIDE_UP    = 0b00010000;
    let COLLIDE_DOWN  = 0b00100000;
    let COLLIDE_LEFT  = 0b01000000;
    let COLLIDE_RIGHT = 0b10000000;


    in program {

        // get the collision mask for the tile at the 
        // given position in the sequence of metatiles
        func get_collision_mask(
            sequence   : *u8 in metatiles_address, // sequence of metatiles' indexes
            position_x :  u8 in b2, // position of the tile along the X-axis
            position_y :  u8 in b3  // position of the tile along the Y-axis [0, 3]
        ) : u8 in a {
            // get the index to read from in the sequence
            y = a = position_x >>> math.F4;

            // get the metatile definition index
            y = a = sequence[y];

            // get the index of the tile in the definition of the metatile
            var tile_index @ &b6 : u8;
            tile_index = a = (position_x & 0b11);
            tile_index = a = (position_y <<< math.F4) | tile_index;
            a = math.mul_word(&tile_index, METATILES_COUNT);

            // address of the metatile definition
            var def_address @ &p4 : *u8;
            <:def_address = a +=      <:(&metatiles as u16);
            >:def_address = a  = x +# >:(&metatiles as u16);

            // get the actual tile value
            x = a = def_address[y];

            // and get the collision mask from it
            return a = collision_masks[x];
        }


        // check for collisions between a primary box and a list of points
        // return true if atleast one collision is detected
        func check_points_collision(
            points_x : *u8  in p0, // sequence of points
            points_y : *u8  in p2, // sequence of points
            length   :  u8  in y,  // length of the sequence in bytes
            box      : Box2 in primary_box // main box to compare with
        ) : u8 in a {

            // iterate the array
            do {
                // check if the point is within the boundaries along the X-axis
                a = points_x[y];
                if box.begin.x_ <= a && a <= box.end.x_ {

                    // check if the point is within the boundaries along the Y-axis
                    a = points_y[y];
                    if box.begin.y_ <= a && a <= box.end.y_ { return a = TRUE; }
                }
            } while { --y; } && !zero;

            // has reached zero => false
            return a = FALSE;
        }


        // check for collisions between a first box and a list of boxes
        // return true if atleast one collision is detected
        func check_boxes_collision(
            boxes_x : *u8  in p0, // sequence of boxes
            boxes_y : *u8  in p2, // sequence of boxes
            length  :  u8  in y,  // length of the sequence in bytes
            size_x  :  u8  in b4, // size of each individual box of the sequence
            size_y  :  u8  in b5, // size of each individual box of the sequence
            box     : Box2 in primary_box // main box to compare with
        ) : u8 in b6 {

            // collision mask to build
            var mask @ &b6 : u8;
            mask = a = 0b00000000;

            // iterate the array
            do {
                // is the primary box potentially colliding downward ?
                x = a = boxes_y[y];
                if a <= box.end.y_ { mask = a = COLLIDE_DOWN; }

                // is the primary box potentially colliding upward ?
                a = x + size_y;
                if box.begin.y_ <= a { mask = a = mask | COLLIDE_UP; }

                // check if the mask contains bits or not
                if { a = mask; } && !zero {

                    // is the primary box colliding right ?
                    x = a = boxes_x[y];
                    if a <= box.end.x_ { mask = a = mask | COLLIDE_RIGHT; }

                    // is the primary box colliding left ?
                    a = x + size_y;
                    if box.begin.y_ <= a { mask = a = mask | COLLIDE_LEFT; }

                    // check if there is an overlap on the X-axis
                    let LR_MASK = COLLIDE_RIGHT | COLLIDE_LEFT;
                    if { a = mask & LR_MASK; } && !zero { return mask; }
                    else { mask = a = 0b00000000; }
                }
            } while { --y; } && !zero;

            // has reached zero => false
            return mask;
        }


        // convert a body position to the corresponding tile position
        // The index of the metatile row to load is returned
        // - (b2) contains the position of the tile along the X-axis
        // - (b3) contains the position of the tile along the Y-axis
        func body_to_tile_position(body_index : u8 in x) : u8 in b0 {

            // store the result in the zeropage
            var
                pos_x    @ &b2,
                pos_y    @ &b3,
                meta_row @ &b0
            : u8;

            // number of bits contained in a single tile
            let TILE_BITS_X = math.F8 + SUB_PIXEL_BITS_X;
            let TILE_BITS_Y = math.F8 + SUB_PIXEL_BITS_Y;

            // compute the position of the tile on the X-axis
            pos_x = a =  bodies_x.position_high[body_index] <<< (8 - TILE_BITS_X);
            pos_x = a = (bodies_x.position_low [body_index] >>> TILE_BITS_X) | pos_x;

            // compute the position of the tile on the Y-axis
            var high : u8 in y;
            var low @ &b1 : u8;
            high = bodies_y.position_high[body_index];

            // how many bits define a single metatile row
            // this has an impact on how to split position data between
            // tile coordinate and metatile sequence to check
            if TILE_BITS_Y >= 8 {

                // tile's bits are in the high byte of the position
                let META_BITS = TILE_BITS_Y - 8;
                meta_row = a =  high >>> META_BITS; 
                pos_y    = a = (high <<< META_BITS) & 0b11;

            } else if 6 >= TILE_BITS_Y {

                // tile's bits are in the low byte of the position
                low      = a = bodies_y.position_low[body_index] >>> TILE_BITS_Y;
                pos_y    = a &= 0b11;
                meta_row = a = high <<< (6 - TILE_BITS_Y);
                meta_row = a = (low >>> math.F4) | meta_row;

            } else {

                // tile's bits are split between the two bytes of the position
                meta_row = a = high >>> 1;
                low      = a = bodies_y.position_low[body_index];
                pos_y    = a = (high <<< 1) & 0b10;
                if low$7 { ++pos_y; }

            }

            return meta_row;
        }


        // convert a body position to the corresponding screen position
        func body_to_screen_position (body_index : u8 in x) {

            // store the result in the zeropage
            var pos_x @ &b0, pos_y @ &b1 : u8;

            // get screen position along X-axis
            pos_x = a =   bodies_x.position_high[body_index] <<< (8 - SUB_PIXEL_BITS_X);
            pos_x = a = ((bodies_x.position_low [body_index] >>> SUB_PIXEL_BITS_X)
                | pos_x) - video.main_scroll.x_;

            // get screen position along Y-axis
            pos_y = a =   bodies_y.position_high[body_index] <<< (8 - SUB_PIXEL_BITS_Y);
            pos_y = a = ((bodies_y.position_low [body_index] >>> SUB_PIXEL_BITS_Y)
                | pos_y) - video.main_scroll.y_;
        }


        // move physics bodies in the simulation
        func move_bodies() {

            // iterate over each body
            x = bodies_count;
            do {
                // update along the X-axis and the Y-axis
                _move_body(&bodies_x, x);
                _move_body(&bodies_y, x);
            } while { --x; } && !zero;
        }

    }

    // treat a single body along a single axis
    inline func _move_body(let bodies : *Bodies, index : u8 in x) {

        // compute the new velocity based on acceleration
        a = bodies.velocity[x] + bodies.acceleration[x];
        math.clamp(a, -MAX_VELOCITY as u8, MAX_VELOCITY as u8);
        bodies.velocity[x] = a;

        // compute the new position based on velocity
        bodies.position_low[x] = a += bodies.position_low[x];
        if negative { a = bodies.position_high[x] -# 0; }
        else        { a = bodies.position_high[x] +# 0; }
        bodies.position_high[x] = a;
    }
}
