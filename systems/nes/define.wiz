/**
 * Define base memory layout
 */

// Specify that the target system is the NES
config {
    format          = "nes" ,
    battery         = false ,
    vertical_mirror = true  ,
    cart_type       = "mmc3", // mapper for per-scanline scrolling
}

import "src/nes";

/**
 * vardata           : uninitialized RAM
 * prgdata/constdata : program and constants (cannot be written to)
 * chrdata           : store tiles (NES specific)
 * varinitdata       : initialized RAM
 * */

bank zeropage  @ 0x0000 : [vardata; 0x0100]; // for variables
bank stack     @ 0x0100 : [vardata; 0x0100]; // for stack
bank oam       @ 0x0200 : [vardata; 0x0100]; // for sprites
bank ram       @ 0x0300 : [vardata; 0x0500]; // ...
bank program   @ 0x8000 : [prgdata; 0x8000]; // for instructions & constants
bank chr                : [chrdata; 0x2000]; // for graphics

in zeropage {

    // 16 Bytes of temporary variables to work with
    var 
        b0, b1, b2, b3, b4, b5, b6, b7,
        b8, b9, bA, bB, bC, bD, bE, bF
    : u8;

    // map the 16 Bytes with words
    var 
        w0 @ &b0, w2 @ &b2, w4 @ &b4, w6 @ &b6,
        w8 @ &b8, wA @ &bA, wC @ &bC, wE @ &bE
    : u16;

    // map the 16 Bytes with pointers
    var 
        p0 @ &b0, p2 @ &b2, p4 @ &b4, p6 @ &b6,
        p8 @ &b8, pA @ &bA, pC @ &bC, pE @ &bE
    : *u8;


    // save the state of registers while executing interrupts
    var tmp_a, tmp_x, tmp_y : u8;

    // count the number of line crossed in the scanline interrupt
    var irq_counter : u8;

    // store the address of a metatiles sequence
    var metatiles_address : *u8; // address of the sequence
    var metatiles_length  :  u8; // length  of the sequence
}

in oam {
	var oam_buffer : [u8; 0x100];
}


in chr {
	const = embed "res/bg-tiles.chr";
	const = embed "res/fg-tiles.chr";
}


in program {
    // palettes loaded on startup
    const initial_palette : [u8] = [
        // nametable palettes
        0x0F, 0x00, 0x10, 0x30,
        0x0F, 0x01, 0x21, 0x30,
        0x0F, 0x05, 0x16, 0x30,
        0x0F, 0x0B, 0x2A, 0x30,
        // sprites palettes
        0x0F, 0x00, 0x10, 0x30,
        0x0F, 0x01, 0x21, 0x30,
        0x0F, 0x05, 0x16, 0x30,
        0x0F, 0x0B, 0x2A, 0x30
    ];

    // collision masks for each of the tiles
    const collision_masks : [u8; 0x100] = [i for let i in 0 .. 0xFF];

    // define the tiles and attributes of the metatiles used
    // metatiles data is split into 17 arrays (16 for tiles and 1 for attributes)
    const metatiles = embed "res/metatiles.bin";
}

// define the number of metatiles defined in the array
let METATILES_COUNT = metatiles.len / (16 + 1);


// number of frames in a single tempo tick
let MUSIC_TEMPO = 30;


// specify that something should be OFF
let OFF = 0;


// boolean values
let TRUE  = 0b1;
let FALSE = 0b0;


// simple 2D vector
struct Vec2 {
    x_ : u8,
    y_ : u8,
}

// define a bounding box to test for collisions
struct Box2 {
    begin : Vec2,
    end   : Vec2,
}

// simple 3D vector
struct Vec3 {
    x_ : u8,
    y_ : u8,
    z_ : u8,
}

// define a bounding box to test for collisions
struct Box3 {
    begin : Vec3,
    end   : Vec3,
}


// push the registers on the stack to switch context
inline func push_registers () {
    push(a);
    push(a = x);
    push(a = y);
}

// pop the registers from the stack to resume previous execution
inline func pop_registers () {
    y = a = pop();
    x = a = pop();
    a = pop();
}

// store registers in memory to execute interrupt
inline func store_registers () {
	tmp_a = a;
	tmp_x = x;
	tmp_y = y;
}

// load registers from memory after executing interrupt
inline func load_registers () {
	a = tmp_a;
	x = tmp_x;
	y = tmp_y;
}

// store the given address in the given storage location
inline func store_address(let storage : *u16, let address : u16) {
    <:*storage = a = <:address;
    >:*storage = a = >:address;
}

// insert a sequence of 16 NOP into the code to help find compiled location
inline func debug_marker() {
    inline for let i in 0x0 .. 0xF { nop(); }
}