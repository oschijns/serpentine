/**
 * Handle playing audio
 */

import "src/nes";
import "src/define";
import "src/math";

namespace audio {

    in zeropage {

        // count the number of frames elapsed
        var tempo_timer : u8;

        // used to read a sequence of numbers and write them into the PPU buffer
        var data_ptr : *u8;
    }


    // number of channels:
    // - 2 pulses
    // - 1 triangle
    // - 1 noise
    // - 1 DMC
    let CHANNELS_COUNT = 4;

    // index of the five channels available
    let CHANNEL_PULSE1   = 0;
    let CHANNEL_PULSE2   = 1;
    let CHANNEL_TRIANGLE = 2;
    let CHANNEL_NOISE    = 3;
    let CHANNEL_DMC      = 4;


    in ram {

        // playing status of each of the channels
        var channels_status : u8;

        // for each of the four channels
        var
            note_index,    // index  of the current note being played in the sequence
            note_length,   // length of the current note
            sequence_low,  // low  byte of the address of the sequence
            sequence_high  // high byte of the address of the sequence
        : [u8; CHANNELS_COUNT];

        // length of the sequence being played for all channels
        var sequence_length : u8;
    }


    in program {

        // play the next note of one of the pulse channels (or the dmc channel)
        // - pulse1 : offset = 0x00
        // - pulse2 : offset = 0x04
        // - dmc    : offset = 0x10
        func next_note_pulse_or_dmc(
            sequence : *u8 in data_ptr,
            index    :  u8 in y,
            offset   :  u8 in x
        ) : u8 in y {

            // start addresses for the channels
            let CONTROL          = &nes.apu.pulse1.control;
            let SWEEP_OR_COUNTER = &nes.apu.pulse1.sweep;
            let LOW_OR_ADDRESS   = &nes.apu.pulse1.low;
            let HIGH_OR_LENGTH   = &nes.apu.pulse1.high;

            // set the four bytes of the channel
            CONTROL         [offset] = a = sequence[index++];
            SWEEP_OR_COUNTER[offset] = a = sequence[index++];
            LOW_OR_ADDRESS  [offset] = a = sequence[index++];
            HIGH_OR_LENGTH  [offset] = a = sequence[index++];

            return index;
        }

    }

    // play the next note of the triangle channel
    inline func next_note_triangle(
        sequence : *u8 in data_ptr,
        index    :  u8 in y
    ) : u8 in y {
        // set the three bytes of the pulse channel
        nes.apu.triangle.control = a = sequence[index++];
        nes.apu.triangle.low     = a = sequence[index++];
        nes.apu.triangle.high    = a = sequence[index++];

        return index;
    }

    // play the next note of the noise channel
    inline func next_note_noise(
        sequence : *u8 in data_ptr,
        index    :  u8 in y
    ) : u8 in y {
        // set the two bytes of the pulse channel
        nes.apu.noise.control = a = sequence[index++];
        nes.apu.noise.pattern = a = sequence[index++];

        return index;
    }

    // update the tempo
    inline func update_tempo() {
        if { --tempo_timer; } && !zero { return; }

        // mask to enable or disable channels
        var status_mask @ &b0 : u8;
        status_mask = a = 0b1 <<< (CHANNELS_COUNT - 1);

        // update each of the channels
        x = CHANNELS_COUNT;
        do {

            // if the channel is done playing the note
            if { --note_length[x]; } && !zero { continue; }

            // setup the address of the sequence to read from
            <:data_ptr = a = sequence_low [x];
            >:data_ptr = a = sequence_high[x];

            // get the index of the note in the sequence
            y = note_index[x];

            // read the length of the note
            if { a = data_ptr[y]; } && negative {

                // silence the channel
                note_length[x] = a &= 0b01111111;
                ++(note_index[x]);

                // disable the channel
                channels_status = a = ~status_mask & channels_status;

            } else {

                // play a note on the channel
                note_length[x] = a;
                ++y;

                // enable the channel
                channels_status = a = status_mask | channels_status;

                // update the channel
                if x == CHANNEL_TRIANGLE {
                    y = next_note_triangle(data_ptr, y);
                } else if x == CHANNEL_NOISE {
                    y = next_note_noise(data_ptr, y);
                } else {
                    // store the value of register x
                    var tmp @ &b1 : u8;
                    tmp = x;
                    a = x << math.F4;
                    y = next_note_pulse_or_dmc(data_ptr, y, a);
                    x = tmp;
                }

                // update the note index
                note_index[x] = a = y;
            }

            // select next bit
            status_mask >>>= 1;

        } while { --x; } && !zero;

        // update the playing status of the channels
        nes.apu.enable = a = channels_status;

        // reset the timer
        tempo_timer = a = MUSIC_TEMPO;
    }

    // initialize the music system
    inline func init() {
        tempo_timer     = a = MUSIC_TEMPO;
        channels_status = a = 0;
        sequence_length = a;
        x = CHANNELS_COUNT;
        do {
            note_index   [x] = a;
            note_length  [x] = a;
            sequence_low [x] = a;
            sequence_high[x] = a;
        } while { --x; } && !zero;

    }
}