"""
    Preconfigured builder for RGBDS projects.
"""


import re
from pathlib           import Path
from logging           import Logger
from SCons.Builder     import Builder
from SCons.Environment import Environment


# Define a process for building rgbds projects
class RGBDSBuilder:

    # Define a process for building a rgbds project
    def __init__(self,
        root_dir     : Path,
        logger       : Logger,
        output_binary: Path,
        linker_script: Path | None = None,
        output_symbol: Path | None = None,
        output_map   : Path | None = None,
        include_paths: list[Path]  = []
    ):
        """
        Create a builder to compile, assemble and link rgbds projects.

        @type  root_dir: Path
        @param root_dir: The root directory of the project

        @type  logger: Logger
        @param logger: The logger to report on build status

        @type  linker_config: Path
        @param linker_config: The path to the linker configuration file

        @type  output_binary: Path
        @param output_binary: The name of the output binary/ROM file

        @type  output_symbol: Path
        @param output_symbol: The name of the output symbol file

        @type  target_cpu: str
        @param target_cpu: The target CPU to build for (default: '6502')

        @type  include_paths: list[Path]
        @param include_paths: The list of include paths for the compiler and assembler
        """

        self.root_dir: Path   = root_dir
        self.logger  : Logger = logger

        # Path to the ld65 linker config file for specifying banks addresses
        link_cfg: str = str(self.root_dir / linker_config)

        # Location of the output binary/ROM
        self.out_bin: Path = self.root_dir / output_binary

        # Location of the output symbol if any
        out_sym: str = ''
        if output_symbol:
            out_sym = f'-Ln {str(self.root_dir / output_symbol)}'

        includes = []
        for path in include_paths:
            includes.append(f'-I{str(self.root_dir / path)}')
        includes = ' '.join(includes)

        # Define the compiler, assembler and linker to use
        self.env: Environment = Environment(
            CC   = 'cc65',
            AS   = 'ca65',
            LINK = 'ld65',
        )

        # Define the compiler step
        compiler = Builder(
            action     = f'$CC $CCFLAGS {includes} --cpu {target_cpu} -Cl -Oirs --add-source -o $TARGET $SOURCE',
            src_suffix = '.c',
            suffix     = '.s'
        )

        # Define the assembler step
        assembler = Builder(
            action     = f'$AS $ASFLAGS {includes} --cpu {target_cpu} -g -o $TARGET $SOURCE',
            src_suffix = '.s',
            suffix     = '.o'
        )

        # Define the linker step
        linker = Builder(
            action     = f'$LINK $LINKFLAGS -C {link_cfg} {out_sym} -o $TARGET $SOURCES',
            src_suffix = '.o',
            suffix     = self.out_bin.suffix
        )

        self.env.Append(BUILDERS = {
            'Compile'  : compiler,
            'Assemble' : assembler, 
            'Link'     : linker
        })


    # Compile, assemble and link all sources found in the project
    def compile_sources(self):
        """
        Compile, assemble and link all sources found in the project
        """

        # Look for sources written by the dev and generated by Jinja
        dir_main: Path = self.root_dir / 'src' / '**'
        dir_gen : Path = self.root_dir / 'target' / 'source'
        dir_out : Path = self.root_dir / 'target' / 'cache'

        # Define the paths to look for sources
        dir_c: list[str] = (
            self.env.Glob(str(dir_main / '*.c'), recursive = True) +
            self.env.Glob(str(dir_gen  / '*.c'))
        )
        dir_s: list[str] = (
            self.env.Glob(str(dir_main / '*.s'), recursive = True) +
            self.env.Glob(str(dir_gen  / '*.s'))
        )

        # Objects files to link
        objects: list = []

        # Compile C sources
        for src in dir_c:
            path: str = str(dir_out / src.name)
            asm = self.env.Compile (path, src)
            obj = self.env.Assemble(path, asm)
            objects.append(obj)
            self.logger.info(f'Compiled {src}')

        # Assemble ASM sources
        for src in dir_s:
            path: str = str(dir_out / src.name)
            obj = self.env.Assemble(path, src)
            objects.append(obj)
            self.logger.info(f'Assembled {src}')

        # Link all object files into the final binary/ROM
        self.env.Link(self.out_bin, objects)
        self.logger.info(f'Linked binary {self.out_bin}')
