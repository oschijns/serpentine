"""
    Preconfigured builder for cc65 projects.
"""

import re
from pathlib           import Path
from logging           import Logger
from SCons.Builder     import Builder
from SCons.Environment import Environment


# Define a process for building cc65 projects
class CC65Builder:

    # Define a process for building a cc65 project
    def __init__(self,
        root_dir     : Path,
        logger       : Logger,
        rom_name     : str,
        target_system: str,
        linker_config: Path,
        include_paths: list[Path] = []):
        """
        Create a builder to compile, assemble and link cc65 projects

        @type  root_dir: Path
        @param root_dir: The root directory of the project

        @type  logger: Logger
        @param logger: The logger to report on build status

        @type  rom_name: str
        @param rom_name: The name of the output ROM file

        @type  target_system: str
        @param target_system: The target system to build for

        @type  linker_config: Path
        @param linker_config: The path to the linker configuration file

        @type  include_paths: list[Path]
        @param include_paths: The list of include paths for the compiler and assembler

        @type  libraries: list[Path]
        @param libraries: The list of libraries to link against
        """

        self.root_dir: Path   = root_dir
        self.logger  : Logger = logger
        self.rom_name: str    = rom_name
        self.system  : str    = target_system.lower()

        if self.system in ['c64', 'nes', 'appleII', 'a2600', 'a5200', 'a7800']:
            cpu = '6502'
        elif self.system in ['pce']:
            cpu = '65c02' # huc6280 is not available, closest is thus 65c02
        else:
            raise ValueError(f'Unsupported target system: {target_system}')

        includes = []
        for path in include_paths:
            includes.append(f'-I{str(path)}')
        includes = ' '.join(includes)

        # Define the compiler, assembler and linker to use
        self.env: Environment = Environment(
            CC   = 'cc65',
            AS   = 'ca65',
            LINK = 'ld65',
        )

        # Define the compiler step
        compiler = Builder(
            action     = f'$CC $CCFLAGS {includes} --cpu {cpu} -Cl -Oirs --add-source -o $TARGET $SOURCE',
            src_suffix = '.c',
            suffix     = '.s'
        )

        # Define the assembler step
        assembler = Builder(
            action     = f'$AS $ASFLAGS {includes} --cpu {cpu} -g -o $TARGET $SOURCE',
            src_suffix = '.s',
            suffix     = '.o'
        )

        # Define the linker step
        linker = Builder(
            action     = f'$LINK $LINKFLAGS -C {str(linker_config)} -o $TARGET $SOURCES',
            src_suffix = '.o',
            suffix     = f'.{self.system}'
        )

        self.env.Append(BUILDERS = {
            'Compile'  : compiler,
            'Assemble' : assembler, 
            'Link'     : linker
        })


    # Compile, assemble and link all sources found in the project
    def compile_sources(self):
        """
        Compile, assemble and link all sources found in the project
        """

        # Look for sources written by the dev and generated by Jinja
        dir_main: Path = self.root_dir / 'src' / '**'
        dir_gen : Path = self.root_dir / 'target' / 'source'
        dir_out : Path = self.root_dir / 'target' / 'cache'

        # Define the paths to look for sources
        dir_c: list[str] = (
            self.env.Glob(str(dir_main / '*.c'), recursive = True) +
            self.env.Glob(str(dir_gen  / '*.c'))
        )
        dir_s: list[str] = (
            self.env.Glob(str(dir_main / '*.s'), recursive = True) +
            self.env.Glob(str(dir_gen  / '*.s'))
        )
        dir_l: list[str] = self.env.Glob(str(self.root_dir / 'libs' / '*.lib'))

        # Objects files to link
        objects: list = []

        # Compile C sources
        for src in dir_c:
            path: str = str(dir_out / src.name)
            asm = self.env.Compile (path, src)
            obj = self.env.Assemble(path, asm)
            objects.append(obj)
            self.logger.info(f'Compiled {src}')

        # Assemble ASM sources
        for src in dir_s:
            path: str = str(dir_out / src.name)
            obj = self.env.Assemble(path, src)
            objects.append(obj)
            self.logger.info(f'Assembled {src}')

        # Link all object files into the final ROM
        self.env.Link(self.rom_name, objects + dir_l)
        self.logger.info(f'Linked ROM {self.rom_name}')
