"""
    Preconfigured builder for cc65 projects.
"""

from pathlib           import Path
from logging           import Logger
from SCons.Builder     import Builder
from SCons.Environment import Environment


# Define a process for building cc65 projects
class CC65Builder:

    # Define a process for building a cc65 project
    def __init__(self,
        root_dir     : Path,
        logger       : Logger,
        rom_name     : str,
        target_system: str,
        linker_config: Path,
        include_paths: list[Path] = []):
        """
        Create a builder to compile, assemble and link cc65 projects

        @type  root_dir: Path
        @param root_dir: The root directory of the project

        @type  logger: Logger
        @param logger: The logger to report on build status

        @type  rom_name: str
        @param rom_name: The name of the output ROM file

        @type  target_system: str
        @param target_system: The target system to build for

        @type  linker_config: Path
        @param linker_config: The path to the linker configuration file

        @type  include_paths: list[Path]
        @param include_paths: The list of include paths for the compiler and assembler
        """

        self.root_dir: Path   = root_dir
        self.logger  : Logger = logger
        self.rom_name: str    = rom_name

        # Define the compiler, assembler and linker to use
        self.env: Environment = Environment(
            # C config
            CC      = 'cc65',
            CCFLAGS = ['-I', 'libs/nesdoug', '-I', 'target/source', '-Oirs', '--add-source', '--cpu', '6502'],

            # ASM config
            AS      = 'ca65',
            ASFLAGS = ['-I', 'libs/nesdoug', '-I', 'target/source', '-g'],

            # Linker config
            LINK = 'ld65',
            LINKFLAGS = ['-C', 'libs/nesdoug/nrom_32k_vert.cfg'],
        )

        # Define the compiler step
        compiler = Builder(
            action     = '$CC $CCFLAGS $_CCCOMCOM -o $TARGET $SOURCE',
            src_suffix = '.c',
            suffix     = '.s'
        )

        # Define the assembler step
        assembler = Builder(
            action     = '$AS $ASFLAGS -o $TARGET $SOURCE',
            src_suffix = '.s',
            suffix     = '.o'
        )

        # Define the linker step
        linker = Builder(
            action     = '$LINK $LINKFLAGS -o $TARGET $SOURCES nes.lib',
            src_suffix = '.o',
            suffix     = '.nes'
        )

        self.env.Append(BUILDERS = {
            'Compile'  : compiler,
            'Assemble' : assembler, 
            'Link'     : linker
        })


    # Compile, assemble and link all sources found in the project
    def compile_sources(self):
        """
        Compile, assemble and link all sources found in the project
        """

        # Look for sources written by the dev and generated by Jinja
        dir_main: Path = self.root_dir / 'src' / '**'
        dir_gen : Path = self.root_dir / 'target' / 'source'
        dir_out : Path = self.root_dir / 'target' / 'cache'

        # Define the paths to look for sources
        dir_c: list[str] = (
            self.env.Glob(str(dir_main / '*.c'), recursive = True) +
            self.env.Glob(str(dir_gen  / '*.c'))
        )
        dir_s: list[str] = (
            self.env.Glob(str(dir_main / '*.s'), recursive = True) +
            self.env.Glob(str(dir_gen  / '*.s'))
        )

        # Objects files to link
        objects: list = []

        # Compile C sources
        for src in dir_c:
            path: str = str(dir_out / src.name)
            asm = self.env.Compile (path, src)
            obj = self.env.Assemble(path, asm)
            objects.append(obj)
            self.logger.info(f'Compiled {src}')

        # Assemble ASM sources
        for src in dir_s:
            path: str = str(dir_out / src.name)
            obj = self.env.Assemble(path, src)
            objects.append(obj)
            self.logger.info(f'Assembled {src}')

        # Link all object files into the final ROM
        self.env.Link(self.rom_name, objects)
        self.logger.info(f'Linked ROM {self.rom_name}')
