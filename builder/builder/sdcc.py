"""
    Preconfigured builder for SDCC projects.
"""

import glob
from pathlib           import Path
from logging           import Logger
from SCons.Builder     import Builder
from SCons.Environment import Environment


# Define a process for building SDCC projects
class SDCCBuilder:

    # Define a process for building a SDCC project
    def __init__(self,
        root_dir     : Path,
        logger       : Logger,
        rom_name     : str,
        target_system: str,
        include_paths: list[Path] = []):
        """
        Create a builder to compile, assemble and link sdcc projects

        @type  root_dir: Path
        @param root_dir: The root directory of the project

        @type  logger: Logger
        @param logger: The logger to report on build status

        @type  rom_name: str
        @param rom_name: The name of the output ROM file

        @type  target_system: str
        @param target_system: The target system to build for

        @type  include_paths: list[Path]
        @param include_paths: The list of include paths for the compiler and assembler
        """

        self.root_dir: Path   = root_dir
        self.logger  : Logger = logger
        self.rom_name: str    = rom_name
        self.system  : str    = target_system.lower()

        if   self.system == 'gb'  : target = 'sm83:gb'
        elif self.system == 'ap'  : target = 'sm83:ap'
        elif self.system == 'duck': target = 'sm83:duck'
        elif self.system == 'sms' : target = 'z80:sms'
        elif self.system == 'gg'  : target = 'z80:gg'
        elif self.system == 'msx' : target = 'z80:msxdos'
        elif self.system == 'nes' : target = 'mos6502:nes'
        else: raise ValueError(f'Unsupported target system: {target_system}')

        includes = []
        for path in include_paths:
            includes.append(f'-I{str(path)}')
        includes = ' '.join(includes)

        libs = []
        for path in glob.glob(str(self.root_dir / 'libs' / '*.lib')):
            libs.append('-l{path}')
        libs = ' '.join(libs)


        # Define the compiler, assembler and linker to use
        self.env: Environment = Environment(
            CC   = 'sdcc',
            AS   = 'sdcc',
            LINK = 'lcc',
        )

        # Define the compiler step
        compiler = Builder(
            action     = f'$CC $CCFLAGS {includes} -m{target} -o $TARGET $SOURCE',
            src_suffix = '.c',
            suffix     = '.s'
        )

        # Define the assembler step
        assembler = Builder(
            action     = f'$AS $ASFLAGS {includes} -m{target} -o $TARGET $SOURCE',
            src_suffix = '.s',
            suffix     = '.o'
        )

        # Define the linker step
        linker = Builder(
            action     = f'$LINK $LINKFLAGS {libs} -m{target} -o $TARGET $SOURCES',
            src_suffix = '.o',
            suffix     = f'.{self.system}'
        )

        self.env.Append(BUILDERS = {
            'Compile'  : compiler,
            'Assemble' : assembler, 
            'Link'     : linker
        })


    # Compile, assemble and link all sources found in the project
    def compile_sources(self):
        """
        Compile, assemble and link all sources found in the project
        """

        # Look for sources written by the dev and generated by Jinja
        dir_main: Path = self.root_dir / 'src' / '**'
        dir_gen : Path = self.root_dir / 'target' / 'source'
        dir_out : Path = self.root_dir / 'target' / 'cache'

        # Define the paths to look for sources
        dir_c: list[str] = (
            self.env.Glob(str(dir_main / '*.c'), recursive = True) +
            self.env.Glob(str(dir_gen  / '*.c'))
        )
        dir_s: list[str] = (
            self.env.Glob(str(dir_main / '*.s'), recursive = True) +
            self.env.Glob(str(dir_gen  / '*.s'))
        )

        # Objects files to link
        objects: list = []

        # Compile C sources
        for src in dir_c:
            path: str = str(dir_out / src.name)
            asm = self.env.Compile (path, src)
            obj = self.env.Assemble(path, asm)
            objects.append(obj)
            self.logger.info(f'Compiled {src}')

        # Assemble ASM sources
        for src in dir_s:
            path: str = str(dir_out / src.name)
            obj = self.env.Assemble(path, src)
            objects.append(obj)
            self.logger.info(f'Assembled {src}')

        # Link all object files into the final ROM
        self.env.Link(self.rom_name, objects)
        self.logger.info(f'Linked ROM {self.rom_name}')
