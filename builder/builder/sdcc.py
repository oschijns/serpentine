"""
    Preconfigured builder for SDCC projects.
"""

import glob
from pathlib           import Path
from logging           import Logger
from SCons.Builder     import Builder
from SCons.Environment import Environment


# Define a process for building SDCC projects
class SDCCBuilder:

    # Define a process for building a SDCC project
    def __init__(self,
        root_dir     : Path,
        logger       : Logger,
        target_system: str,
        linker_config: Path,
        output_binary: Path,
        output_symbol: Path | None = None,
        include_paths: list[Path] = []):
        """
        Create a builder to compile, assemble and link sdcc projects.
        Supports the following targets:
        - 'sm83:gb'
        - 'sm83:ap'
        - 'sm83:duck'
        - 'z80:sms'
        - 'z80:gg'
        - 'z80:msxdos'
        - 'mos6502:nes'

        @type  root_dir: Path
        @param root_dir: The root directory of the project

        @type  logger: Logger
        @param logger: The logger to report on build status

        @type  target_system: str
        @param target_system: The target system to build for

        @type  linker_config: Path
        @param linker_config: The path to the linker configuration file

        @type  output_binary: Path
        @param output_binary: The name of the output binary/ROM file

        @type  output_symbol: Path
        @param output_symbol: The name of the output symbol file

        @type  include_paths: list[Path]
        @param include_paths: The list of include paths for the compiler and assembler
        """

        self.root_dir: Path   = root_dir
        self.logger  : Logger = logger

        includes = []
        for path in include_paths:
            includes.append(f'-I{str(self.root_dir / path)}')
        includes = ' '.join(includes)


        # Define the compiler, assembler and linker to use
        self.env: Environment = Environment(
            CC   = 'sdcc',
            AS   = 'sdcc',
            LINK = 'sdcc',
        )

        # Define the compiler step
        compiler = Builder(
            action     = f'$CC $CCFLAGS {includes} -m{target_system} -c -o $TARGET $SOURCE',
            src_suffix = '.c',
            suffix     = '.o'
        )

        # Define the assembler step
        assembler = Builder(
            action     = f'$AS $ASFLAGS {includes} -m{target_system} -c -o $TARGET $SOURCE',
            src_suffix = '.s',
            suffix     = '.o'
        )

        # Define the linker step
        linker = Builder(
            action     = f'$LINK $LINKFLAGS -m{target_system} -o $TARGET $SOURCES',
            src_suffix = '.o',
            suffix     = self.out_bin.suffix
        )

        self.env.Append(BUILDERS = {
            'Compile'  : compiler,
            'Assemble' : assembler, 
            'Link'     : linker
        })


    # Compile, assemble and link all sources found in the project
    def compile_sources(self):
        """
        Compile, assemble and link all sources found in the project
        """

        # Look for sources written by the dev and generated by Jinja
        dir_main: Path = self.root_dir / 'src' / '**'
        dir_gen : Path = self.root_dir / 'target' / 'source'
        dir_out : Path = self.root_dir / 'target' / 'cache'

        # Define the paths to look for sources
        dir_c: list[str] = (
            self.env.Glob(str(dir_main / '*.c'), recursive = True) +
            self.env.Glob(str(dir_gen  / '*.c'))
        )
        dir_s: list[str] = (
            self.env.Glob(str(dir_main / '*.s'), recursive = True) +
            self.env.Glob(str(dir_gen  / '*.s'))
        )

        # Objects files to link
        objects: list = []

        # Compile C sources
        for src in dir_c:
            path: str = str(dir_out / src.name)
            asm = self.env.Compile (path, src)
            obj = self.env.Assemble(path, asm)
            objects.append(obj)
            self.logger.info(f'Compiled {src}')

        # Assemble ASM sources
        for src in dir_s:
            path: str = str(dir_out / src.name)
            obj = self.env.Assemble(path, src)
            objects.append(obj)
            self.logger.info(f'Assembled {src}')

        # Link all object files into the final ROM
        self.env.Link(self.rom_name, objects)
        self.logger.info(f'Linked ROM {self.rom_name}')
